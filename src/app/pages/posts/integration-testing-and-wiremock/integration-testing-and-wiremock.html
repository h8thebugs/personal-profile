<h1 id="integration-testing-and-wiremock">Integration testing And Wiremock</h1>
<p>Once I was tasked to create a backend service that needed to connect to a <code>Version Control System</code> (you
  can imagine something similar to Git for example) to obtain some metadata regarding projects and its files, and to
  extract some information from the files themselves. The goal was to automate the process of creating some kind of
  security bulletins for these projects and their different versions. The most challenging thing on this service was to
  find a way to test the business logic of the application. </p>
<p>I will share some details regarding <code>testing in Spring Boot</code>, how I chose my testing strategy, how I used
  <code>WireMock</code> to provide a stable test environment and how can one configure it for some less-common
  use-cases.</p>

<h2 id="defining-the-testing-strategy">Defining the testing strategy</h2>
<p>When you write tests, you have to isolate them from external dependencies.</p>
<p>In unit tests this means dependencies e.g. another service in your <code>service layer</code> or the repository the
  service accesses. For this situation <a href="https://site.mockito.org/">Mockito</a> is the solution to-go in Java.
  The problem is that in my service layer I interact with a lot of the file utilities, since I receive ZIP archives from
  the version control system, and I need to parse it, search for a specific file, and so on. This makes it really
  tedious to mock, to construct files to return, and would result in tests where the setup would be more complex then
  the teardown, which signals that it&#39;s not the best strategy to aim for.</p>
<p>Another possibility is to aim for integration testing. In that case there are other possibilities to isolate the
  tests in further layers. If you have a database you can use an in-memory DB like <a
    href="https://github.com/h2database/h2database">H2</a>, or if your CI environment permits it, you can use <a
    href="https://java.testcontainers.org/">TestContainers</a>. When you communicate with other system through <code>REST
    APIs</code> however, <a href="https://wiremock.org/docs/getting-started/">WireMock</a> is the solution to go for.
  You can predefine responses for your endpoints instead of connecting to a live test server, which has the benefit that
  there&#39;s no state that will be persisted and needs to be managed, making your tests easy to reproduce and to
  execute them repeatedly. For my use-case this approach would be great, because I can configure it easily to return the
  same metadata and file as the original server does for any of the invoked endpoint, and I don&#39;t need to deal with
  mocking all the file parsing utilities that I use, I just need to verify the output.</p>

<h2 id="setting-up-integration-tests-with-wiremock">Setting up Integration Tests with WireMock</h2>
<p>To integrate <code>WireMock</code> seemlessly into you <code>Spring Boot</code> tests, the framework released a
  fairly new package called <a
    href="https://cloud.spring.io/spring-cloud-contract/1.2.x/multi/multi__spring_cloud_contract_stub_runner.html">Spring
    Cloud Contract Stub Runner</a>, which makes it easy to stub the responses (and also can help with a lot of advanced
  stuff with other spring cloud contract packages, but for this example we use it only to set up Wiremock). Here&#39;s
  how you can add the dependency in Maven:</p>
<p>With this package, you can create a test profile replacing the connection string to the real server with your
  Wiremock instance using a dynamically allocated port:</p>
<p>You can define your <code>Spring MVC Test</code> like this:</p>
<p>WireMock has a standard directory where it searches for your files you want to use in their configurations, which is
  <em>src/test/resources/__files</em>. Your <code>API mappings</code> by default are under <em>src/test/resources/mappings</em>.
  These are <code>JSON</code> files that describe for what request, what response should be given:</p>
<p>In my case, I want to configure it so it returns a ZIP file for an example request which accesses the POM of a Spring
  Boot project, and my application will extract the dependencies and the versions of it. I obtained from the real server
  the data I want and put it under <em>src/test/resources/__files/pom.xml.zip</em>. Now I can create a request matcher
  with the exact request my application would make and set the response for it:</p>
<p>Now, let&#39;s look back to our test and write a test case for it:</p>
